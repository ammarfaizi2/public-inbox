#!/usr/bin/perl -w
# Copyright (C) 2018 all contributors <meta@public-inbox.org>
# License: AGPL-3.0+ <https://www.gnu.org/licenses/agpl-3.0.txt>
use strict;
use warnings;
use Getopt::Long qw(:config gnu_getopt no_ignore_case auto_abbrev);
use PublicInbox::Search;
use PublicInbox::Config;
use PublicInbox::InboxWritable;
use Cwd 'abs_path';
use File::Temp qw(tempdir);
use File::Path qw(remove_tree);
use PublicInbox::Spawn qw(spawn);
my $usage = "Usage: public-inbox-compact REPO_DIR\n";
my $dir = shift or die $usage;
my $config = eval { PublicInbox::Config->new };
my $ibx;
$dir = abs_path($dir);
if ($config) {
	$config->each_inbox(sub {
		$ibx = $_[0] if abs_path($_[0]->{mainrepo}) eq $dir
	});
}
unless ($ibx) {
	warn "W: $dir not configured in ".
		PublicInbox::Config::default_file() . "\n";
	$ibx = {
		mainrepo => $dir,
		name => 'ignored',
		address => [ 'old@example.com' ],
	};
	$ibx = PublicInbox::Inbox->new($ibx);
}
my $v = ($ibx->{version} || 1);
$ibx = PublicInbox::InboxWritable->new($ibx);
$ibx->umask_prepare;

sub commit_changes ($$$) {
	my ($im, $old, $new) = @_;
	my @st = stat($old) or die "failed to stat($old): $!\n";

	my $over = "$old/over.sqlite3";
	if (-f $over) {
		require PublicInbox::Over;
		$over = PublicInbox::Over->new($over);
		$over->connect->sqlite_backup_to_file("$new/over.sqlite3");
	}
	rename($old, "$new/old") or die "rename $old => $new/old: $!\n";
	chmod($st[2] & 07777, $new) or die "chmod $old: $!\n";
	rename($new, $old) or die "rename $new => $old: $!\n";
	$im->lock_release;
	remove_tree("$old/old") or die "failed to remove $old/old: $!\n";
}

# we rely on --no-renumber to keep docids synched to NNTP
my @compact = qw(xapian-compact --no-renumber);
if ($v == 2) {
	require PublicInbox::V2Writable;
	my $v2w = PublicInbox::V2Writable->new($ibx);
	my $xap_v = 'xap'.PublicInbox::Search::SCHEMA_VERSION;
	my $old = "$dir/$xap_v";
	opendir my $dh, $old or die "Failed to opendir $old: $!\n";
	my $new = tempdir('compact-XXXXXXXX', CLEANUP => 1, DIR => $dir);
	$ibx->with_umask(sub {
		$v2w->lock_acquire;
		my %pids;
		while (defined(my $dn = readdir($dh))) {
			if ($dn =~ /\A\d+\z/) {
				my $cmd = [ @compact, "$old/$dn", "$new/$dn" ];
				$pids{spawn($cmd)} = join(' ', @$cmd);
			} elsif ($dn eq '.' || $dn eq '..') {
			} elsif ($dn =~ /\Aover\.sqlite3/) {
			} else {
				warn "W: skipping unknown Xapian DB: $old/$dn\n"
			}
		}
		close $dh;
		die "No Xapian parts found in $old\n" unless keys %pids;
		while (scalar keys %pids) {
			my $pid = waitpid(-1, 0);
			my $desc = delete $pids{$pid};
			die "$desc failed: $?\n" if $?;
		}
		commit_changes($v2w, $old, $new);
	});
} elsif ($v == 1) {
	require PublicInbox::Import;
	my $im = PublicInbox::Import->new($ibx->git, undef, undef, $ibx);
	my $xap_v = 'xapian'.PublicInbox::Search::SCHEMA_VERSION;
	my $v1_root = "$dir/public-inbox";
	my $old = "$v1_root/$xap_v";
	-d $old or die "$old does not exist\n";
	my $new = tempdir('compact-XXXXXXXX', CLEANUP => 1, DIR => $v1_root);
	$ibx->with_umask(sub {
		$im->lock_acquire;
		PublicInbox::Import::run_die([@compact, $old, $new]);
		commit_changes($im, $old, $new);
	});
} else {
	die "Unsupported inbox version: $v\n";
}
