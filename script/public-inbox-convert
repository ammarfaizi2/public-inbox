#!/usr/bin/perl -w
# Copyright (C) 2018-2019 all contributors <meta@public-inbox.org>
# License: AGPL-3.0+ <http://www.gnu.org/licenses/agpl-3.0.txt>
use strict;
use warnings;
use Getopt::Long qw(:config gnu_getopt no_ignore_case auto_abbrev);
use PublicInbox::InboxWritable;
use PublicInbox::Config;
use PublicInbox::V2Writable;
use PublicInbox::Git;
use PublicInbox::Spawn qw(spawn);
use Cwd 'abs_path';
use File::Copy 'cp'; # preserves permissions:
my $usage = "Usage: public-inbox-convert OLD NEW\n";
my $jobs;
my $index = 1;
my %opts = (
	'--jobs|j=i' => \$jobs,
	'--index!' => \$index,
);
GetOptions(%opts) or die "bad command-line args\n$usage";
my $old_dir = shift or die $usage;
my $new_dir = shift or die $usage;
die "$new_dir exists\n" if -d $new_dir;
die "$old_dir not a directory\n" unless -d $old_dir;
my $config = eval { PublicInbox::Config->new };
$old_dir = abs_path($old_dir);
my $old;
if ($config) {
	$config->each_inbox(sub {
		$old = $_[0] if abs_path($_[0]->{inboxdir}) eq $old_dir;
	});
}
unless ($old) {
	warn "W: $old_dir not configured in " .
		PublicInbox::Config::default_file() . "\n";
	$old = {
		inboxdir => $old_dir,
		name => 'ignored',
		address => [ 'old@example.com' ],
	};
	$old = PublicInbox::Inbox->new($old);
}
$old = PublicInbox::InboxWritable->new($old);
if ($old->version >= 2) {
	die "Only conversion from v1 inboxes is supported\n";
}
my $new = { %$old };
$new->{inboxdir} = abs_path($new_dir);
$new->{version} = 2;
$new = PublicInbox::InboxWritable->new($new);
my $v2w;
$old->umask_prepare;

sub link_or_copy ($$) {
	my ($src, $dst) = @_;
	link($src, $dst) and return;
	$!{EXDEV} or warn "link $src, $dst failed: $!, trying cp\n";
	cp($src, $dst) or die "cp $src, $dst failed: $!\n";
}

$old->with_umask(sub {
	my $old_cfg = "$old->{inboxdir}/config";
	local $ENV{GIT_CONFIG} = $old_cfg;
	my $new_cfg = "$new->{inboxdir}/all.git/config";
	$v2w = PublicInbox::V2Writable->new($new, 1);
	$v2w->init_inbox($jobs);
	unlink $new_cfg;
	link_or_copy($old_cfg, $new_cfg);
	if (my $alt = $new->{altid}) {
		require PublicInbox::AltId;
		foreach my $i (0..$#$alt) {
			my $src = PublicInbox::AltId->new($old, $alt->[$i], 0);
			$src->mm_alt or next;
			my $dst = PublicInbox::AltId->new($new, $alt->[$i], 1);
			$dst = $dst->{filename};
			$src->mm_alt->{dbh}->sqlite_backup_to_file($dst);
		}
	}
	my $desc = "$old->{inboxdir}/description";
	link_or_copy($desc, "$new->{inboxdir}/description") if -e $desc;
	my $clone = "$old->{inboxdir}/cloneurl";
	if (-e $clone) {
		warn <<"";
$clone may not be valid after migrating to v2, not copying

	}
});
my $state = '';
my ($prev, $from);
my $head = $old->{ref_head} || 'HEAD';
my ($rd, $pid) = $old->git->popen(qw(fast-export --use-done-feature), $head);
$v2w->idx_init;
my $im = $v2w->importer;
my ($r, $w) = $im->gfi_start;
my $h = '[0-9a-f]';
my %D;
my $last;
while (<$rd>) {
	if ($_ eq "blob\n") {
		$state = 'blob';
	} elsif (/^commit /) {
		$state = 'commit';
	} elsif (/^data ([0-9]+)/) {
		my $len = $1;
		$w->print($_) or $im->wfail;
		while ($len) {
			my $n = read($rd, my $tmp, $len) or die "read: $!";
			warn "$n != $len\n" if $n != $len;
			$len -= $n;
			$w->print($tmp) or $im->wfail;
		}
		next;
	} elsif ($state eq 'commit') {
		if (m{^M 100644 :([0-9]+) (${h}{2}/${h}{38})}o) {
			my ($mark, $path) = ($1, $2);
			$D{$path} = $mark;
			if ($last && $last ne 'm') {
				$w->print("D $last\n") or $im->wfail;
			}
			$w->print("M 100644 :$mark m\n") or $im->wfail;
			$last = 'm';
			next;
		}
		if (m{^D (${h}{2}/${h}{38})}o) {
			my $mark = delete $D{$1};
			defined $mark or die "undeleted path: $1\n";
			if ($last && $last ne 'd') {
				$w->print("D $last\n") or $im->wfail;
			}
			$w->print("M 100644 :$mark d\n") or $im->wfail;
			$last = 'd';
			next;
		}
		if (m{^from (:[0-9]+)}) {
			$prev = $from;
			$from = $1;
			# no next
		}
	}
	last if $_ eq "done\n";
	$w->print($_) or $im->wfail;
}
$w = $r = undef;
close $rd or die "close fast-export: $!\n";
waitpid($pid, 0) or die "waitpid failed: $!\n";
$? == 0 or die "fast-export failed: $?\n";
$v2w->done;
if (my $mm = $old->mm) {
	$old->cleanup;
	$mm->{dbh}->sqlite_backup_to_file("$new_dir/msgmap.sqlite3");

	# we want to trigger a reindex, not a from scratch index if
	# we're reusing the msgmap from an existing v1 installation.
	$v2w->idx_init;
	my $epoch0 = PublicInbox::Git->new($v2w->git_init(0));
	chop(my $cmt = $epoch0->qx(qw(rev-parse --verify), $head));
	$v2w->last_epoch_commit(0, $cmt);
}
if ($index) {
	$v2w->index_sync({reindex => 1});
	$v2w->done;
}
