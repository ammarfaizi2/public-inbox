#!perl -w
# Copyright (C) 2020-2021 all contributors <meta@public-inbox.org>
# License: AGPL-3.0+ <https://www.gnu.org/licenses/agpl-3.0.txt>
use strict;
use v5.10.1;
use Socket qw(AF_UNIX SOCK_SEQPACKET MSG_EOR pack_sockaddr_un);
use Errno qw(EINTR ECONNRESET);
use PublicInbox::CmdIPC4;
my $narg = 5;
my ($sock, $pwd);
my $recv_cmd = PublicInbox::CmdIPC4->can('recv_cmd4');
my $send_cmd = PublicInbox::CmdIPC4->can('send_cmd4') // do {
	require PublicInbox::Spawn; # takes ~50ms even if built *sigh*
	$recv_cmd = PublicInbox::Spawn->can('recv_cmd4');
	PublicInbox::Spawn->can('send_cmd4');
};

sub sigchld {
	my ($sig) = @_;
	my $flags = $sig ? POSIX::WNOHANG() : 0;
	while (waitpid(-1, $flags) > 0) {}
}

sub exec_cmd {
	my ($fds, $argc, @argv) = @_;
	my @m = (*STDIN{IO}, '<&=',  *STDOUT{IO}, '>&=', *STDERR{IO}, '>&=');
	my @rdr;
	for my $fd (@$fds) {
		my ($old_io, $mode) = splice(@m, 0, 2);
		open(my $tmpfh, $mode, $fd) or die "open $mode$fd: $!";
		push @rdr, $old_io, $mode, $tmpfh;
	}
	require POSIX; # WNOHANG
	$SIG{CHLD} = \&sigchld;
	my $pid = fork // die "fork: $!";
	if ($pid == 0) {
		my %env = map { split(/=/, $_, 2) } splice(@argv, $argc);
		while (my ($old_io, $mode, $tmpfh) = splice(@rdr, 0, 3)) {
			open $old_io, $mode, $tmpfh or die "open $mode: $!";
		}
		%ENV = (%ENV, %env);
		exec(@argv);
		die "exec: @argv: $!";
	}
}

if ($send_cmd && eval {
	my $path = do {
		my $runtime_dir = ($ENV{XDG_RUNTIME_DIR} // '') . '/lei';
		if ($runtime_dir eq '/lei') {
			require File::Spec;
			$runtime_dir = File::Spec->tmpdir."/lei-$<";
		}
		unless (-d $runtime_dir) {
			require File::Path;
			File::Path::mkpath($runtime_dir, 0, 0700);
		}
		"$runtime_dir/$narg.seq.sock";
	};
	my $addr = pack_sockaddr_un($path);
	socket($sock, AF_UNIX, SOCK_SEQPACKET, 0) or die "socket: $!";
	unless (connect($sock, $addr)) { # start the daemon if not started
		local $ENV{PERL5LIB} = join(':', @INC);
		open(my $daemon, '-|', $^X, qw[-MPublicInbox::LEI
			-E PublicInbox::LEI::lazy_start(@ARGV)],
			$path, $! + 0, $narg) or die "popen: $!";
		while (<$daemon>) { warn $_ } # EOF when STDERR is redirected
		close($daemon) or warn <<"";
lei-daemon could not start, exited with \$?=$?

		# try connecting again anyways, unlink+bind may be racy
		connect($sock, $addr) or die <<"";
connect($path): $! (after attempted daemon start)
Falling back to (slow) one-shot mode

	}
	1;
}) { # (Socket::MsgHdr|Inline::C), $sock, $pwd are all available:
	open my $dh, '<', '.' or die "open(.) $!";
	my $buf = join("\0", scalar(@ARGV), @ARGV);
	while (my ($k, $v) = each %ENV) { $buf .= "\0$k=$v" }
	$buf .= "\0\0";
	$send_cmd->($sock, [ 0, 1, 2, fileno($dh) ], $buf, MSG_EOR);
	my $x_it_code = 0;
	while (1) {
		my (@fds) = $recv_cmd->($sock, $buf, 4096 * 33);
		if (scalar(@fds) == 1 && !defined($fds[0])) {
			last if $! == ECONNRESET;
			next if $! == EINTR;
			die "recvmsg: $!";
		}
		last if $buf eq '';
		if ($buf =~ /\Ax_it ([0-9]+)\z/) {
			$x_it_code = $1 + 0;
			last;
		} elsif ($buf =~ /\Aexec (.+)\z/) {
			exec_cmd(\@fds, split(/\0/, $1));
		} else {
			sigchld();
			die $buf;
		}
	}
	sigchld();
	if (my $sig = ($x_it_code & 127)) {
		kill $sig, $$;
		sleep;
	}
	exit($x_it_code >> 8);
} else { # for systems lacking Socket::MsgHdr or Inline::C
	warn $@ if $@;
	require PublicInbox::LEI;
	PublicInbox::LEI::oneshot(__PACKAGE__);
}
