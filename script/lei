#!perl -w
# Copyright (C) 2020-2021 all contributors <meta@public-inbox.org>
# License: AGPL-3.0+ <https://www.gnu.org/licenses/agpl-3.0.txt>
use strict;
use v5.10.1;
use Socket qw(AF_UNIX SOCK_SEQPACKET MSG_EOR pack_sockaddr_un);
use PublicInbox::CmdIPC4;
my $narg = 5;
my $sock;
my $recv_cmd = PublicInbox::CmdIPC4->can('recv_cmd4');
my $send_cmd = PublicInbox::CmdIPC4->can('send_cmd4') // do {
	require PublicInbox::Spawn; # takes ~50ms even if built *sigh*
	$recv_cmd = PublicInbox::Spawn->can('recv_cmd4');
	PublicInbox::Spawn->can('send_cmd4');
};

sub sigchld {
	my ($sig) = @_;
	my $flags = $sig ? POSIX::WNOHANG() : 0;
	while (waitpid(-1, $flags) > 0) {}
}

sub exec_cmd {
	my ($fds, $argc, @argv) = @_;
	my @old = (*STDIN{IO}, *STDOUT{IO}, *STDERR{IO});
	my @rdr;
	for my $fd (@$fds) {
		open(my $tmpfh, '+<&=', $fd) or die "open +<&=$fd: $!";
		push @rdr, shift(@old), $tmpfh;
	}
	require POSIX; # WNOHANG
	$SIG{CHLD} = \&sigchld;
	my $pid = fork // die "fork: $!";
	if ($pid == 0) {
		my %env = map { split(/=/, $_, 2) } splice(@argv, $argc);
		while (my ($old_io, $tmpfh) = splice(@rdr, 0, 2)) {
			open $old_io, '+<&', $tmpfh or die "open +<&=: $!";
		}
		%ENV = (%ENV, %env);
		exec(@argv);
		die "exec: @argv: $!";
	}
}

if ($send_cmd && eval {
	my $path = do {
		my $runtime_dir = ($ENV{XDG_RUNTIME_DIR} // '') . '/lei';
		if ($runtime_dir eq '/lei') {
			require File::Spec;
			$runtime_dir = File::Spec->tmpdir."/lei-$<";
		}
		unless (-d $runtime_dir) {
			require File::Path;
			File::Path::mkpath($runtime_dir, 0, 0700);
		}
		"$runtime_dir/$narg.seq.sock";
	};
	my $addr = pack_sockaddr_un($path);
	socket($sock, AF_UNIX, SOCK_SEQPACKET, 0) or die "socket: $!";
	unless (connect($sock, $addr)) { # start the daemon if not started
		local $ENV{PERL5LIB} = join(':', @INC);
		open(my $daemon, '-|', $^X, qw[-MPublicInbox::LEI
			-E PublicInbox::LEI::lazy_start(@ARGV)],
			$path, $! + 0, $narg) or die "popen: $!";
		while (<$daemon>) { warn $_ } # EOF when STDERR is redirected
		close($daemon) or warn <<"";
lei-daemon could not start, exited with \$?=$?

		# try connecting again anyways, unlink+bind may be racy
		connect($sock, $addr) or die <<"";
connect($path): $! (after attempted daemon start)
Falling back to (slow) one-shot mode

	}
	# (Socket::MsgHdr|Inline::C), $sock are all available:
	open my $dh, '<', '.' or die "open(.) $!";
	my $buf = join("\0", scalar(@ARGV), @ARGV);
	while (my ($k, $v) = each %ENV) { $buf .= "\0$k=$v" }
	$buf .= "\0\0";
	my $n = $send_cmd->($sock, [0, 1, 2, fileno($dh)], $buf, MSG_EOR);
	if (!$n && $!{ETOOMANYREFS} && eval { require BSD::Resource }) {
		my $NOFILE = BSD::Resource::RLIMIT_NOFILE();
		my ($s, $h) = BSD::Resource::getrlimit($NOFILE);
		if ($s < $h && BSD::Resource::setrlimit($NOFILE, $h, $h)) {
			$n = $send_cmd->($sock, [0, 1, 2, fileno($dh)],
					$buf, MSG_EOR);
		}
	}
	if (!$n) {
		die "sendmsg: $! (check RLIMIT_NOFILE)\n" if $!{ETOOMANYREFS};
		die "sendmsg: $!\n";
	}
	1;
}) { # connected and request sent to lei-daemon, wait for responses or EOF
	my $x_it_code = 0;
	while (1) {
		my (@fds) = $recv_cmd->($sock, my $buf, 4096 * 33);
		if (scalar(@fds) == 1 && !defined($fds[0])) {
			next if $!{EINTR};
			last if $!{ECONNRESET};
			die "recvmsg: $!";
		}
		last if $buf eq '';
		if ($buf =~ /\Ax_it ([0-9]+)\z/) {
			$x_it_code = $1 + 0;
			last;
		} elsif ($buf =~ /\Achild_error ([0-9]+)\z/) {
			$x_it_code = $1 + 0;
		} elsif ($buf =~ /\Aexec (.+)\z/) {
			exec_cmd(\@fds, split(/\0/, $1));
		} else {
			sigchld();
			die $buf;
		}
	}
	sigchld();
	if (my $sig = ($x_it_code & 127)) {
		kill $sig, $$;
		sleep(1) while 1;
	}
	exit($x_it_code >> 8);
} else { # for systems lacking Socket::MsgHdr or Inline::C
	warn $@ if $@;
	require PublicInbox::LEI;
	PublicInbox::LEI::oneshot(__PACKAGE__);
}
