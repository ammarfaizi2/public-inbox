#!perl -w
# Copyright (C) 2020 all contributors <meta@public-inbox.org>
# License: AGPL-3.0+ <https://www.gnu.org/licenses/agpl-3.0.txt>
use strict;
use v5.10.1;
use Socket qw(AF_UNIX SOCK_STREAM pack_sockaddr_un);

if (eval { require IO::FDPass; 1 }) { # use daemon to reduce load time
	my $path = do {
		my $runtime_dir = ($ENV{XDG_RUNTIME_DIR} // '') . '/lei';
		if ($runtime_dir eq '/lei') {
			require File::Spec;
			$runtime_dir = File::Spec->tmpdir."/lei-$<";
		}
		unless (-d $runtime_dir) {
			require File::Path;
			File::Path::mkpath($runtime_dir, 0, 0700);
		}
		"$runtime_dir/sock";
	};
	my $addr = pack_sockaddr_un($path);
	socket(my $sock, AF_UNIX, SOCK_STREAM, 0) or die "socket: $!";
	unless (connect($sock, $addr)) { # start the daemon if not started
		my $err = $! + 0;
		my $env = { PERL5LIB => join(':', @INC) };
		my $cmd = [ $^X, qw[-MPublicInbox::LEI
			-E PublicInbox::LEI::lazy_start(@ARGV)],
			$path, $err ];
		require PublicInbox::Spawn;
		waitpid(PublicInbox::Spawn::spawn($cmd, $env), 0);
		warn "lei-daemon exited with \$?=$?\n" if $?;

		# try connecting again anyways, unlink+bind may be racy
		connect($sock, $addr) or die
			"connect($path): $! (after attempted daemon start)";
	}
	require Cwd;
	my $cwd = Cwd::fastcwd() // die "fastcwd: $!";
	my $pwd = $ENV{PWD} // '';
	if ($pwd eq $cwd) { # likely, all good
	} elsif ($pwd) { # prefer ENV{PWD} if it's a symlink to real cwd
		my @st_cwd = stat($cwd) or die "stat(cwd=$cwd): $!\n";
		my @st_pwd = stat($pwd);
		# make sure st_dev/st_ino match for {PWD} to be valid
		$pwd = $cwd if (!@st_pwd || $st_pwd[1] != $st_cwd[1] ||
					$st_pwd[0] != $st_cwd[0]);
	} else {
		$pwd = $cwd;
	}
	local $ENV{PWD} = $pwd;
	my $buf = "$$\0\0>" . join("]\0[", @ARGV) . "\0\0>";
	while (my ($k, $v) = each %ENV) { $buf .= "$k=$v\0" }
	$buf .= "\0\0";
	select $sock;
	$| = 1; # unbuffer selected $sock
	IO::FDPass::send(fileno($sock), $_) for (0..2);
	print $sock $buf or die "print(sock, buf): $!";
	while ($buf = <$sock>) {
		$buf =~ /\Aexit=([0-9]+)\n\z/ and exit($1 + 0);
		die $buf;
	}
} else { # for systems lacking IO::FDPass
	require PublicInbox::LEI;
	PublicInbox::LEI::oneshot(__PACKAGE__);
}
