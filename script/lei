#!perl -w
# Copyright (C) 2020-2021 all contributors <meta@public-inbox.org>
# License: AGPL-3.0+ <https://www.gnu.org/licenses/agpl-3.0.txt>
use strict;
use v5.10.1;
use Socket qw(AF_UNIX SOCK_STREAM pack_sockaddr_un);
use PublicInbox::CmdIPC4;
my $narg = 4;
my $recv_cmd = PublicInbox::CmdIPC4->can('recv_cmd4');
my $send_cmd = PublicInbox::CmdIPC4->can('send_cmd4') // do {
	require PublicInbox::CmdIPC1; # 2nd choice
	$narg = 1;
	$recv_cmd = PublicInbox::CmdIPC1->can('recv_cmd1');
	PublicInbox::CmdIPC1->can('send_cmd1');
} // do {
	require PublicInbox::Spawn; # takes ~50ms even if built *sigh*
	$narg = 4;
	$recv_cmd = PublicInbox::Spawn->can('recv_cmd4');
	PublicInbox::Spawn->can('send_cmd4');
};

sub exec_cmd {
	my ($fds, $argc, @argv) = @_;
	my %env = map { split(/=/, $_, 2) } splice(@argv, $argc);
	my @m = (*STDIN{IO}, '<&=',  *STDOUT{IO}, '>&=',
		*STDERR{IO}, '>&=');
	for my $fd (@$fds) {
		my ($old_io, $mode) = splice(@m, 0, 2);
		open($old_io, $mode, $fd) or die "open $mode$fd: $!";
	}
	%ENV = (%ENV, %env);
	exec(@argv);
	die "exec: @argv: $!";
}

my ($sock, $pwd);
if ($send_cmd && eval {
	my $path = do {
		my $runtime_dir = ($ENV{XDG_RUNTIME_DIR} // '') . '/lei';
		if ($runtime_dir eq '/lei') {
			require File::Spec;
			$runtime_dir = File::Spec->tmpdir."/lei-$<";
		}
		unless (-d $runtime_dir) {
			require File::Path;
			File::Path::mkpath($runtime_dir, 0, 0700);
		}
		"$runtime_dir/$narg.sock";
	};
	my $addr = pack_sockaddr_un($path);
	socket($sock, AF_UNIX, SOCK_STREAM, 0) or die "socket: $!";
	unless (connect($sock, $addr)) { # start the daemon if not started
		local $ENV{PERL5LIB} = join(':', @INC);
		open(my $daemon, '-|', $^X, qw[-MPublicInbox::LEI
			-E PublicInbox::LEI::lazy_start(@ARGV)],
			$path, $! + 0, $narg) or die "popen: $!";
		while (<$daemon>) { warn $_ } # EOF when STDERR is redirected
		close($daemon) or warn <<"";
lei-daemon could not start, exited with \$?=$?

		# try connecting again anyways, unlink+bind may be racy
		connect($sock, $addr) or die <<"";
connect($path): $! (after attempted daemon start)
Falling back to (slow) one-shot mode

	}
	require Cwd;
	$pwd = $ENV{PWD} // '';
	my $cwd = Cwd::fastcwd() // die "fastcwd(PWD=$pwd): $!";
	if ($pwd ne $cwd) { # prefer ENV{PWD} if it's a symlink to real cwd
		my @st_cwd = stat($cwd) or die "stat(cwd=$cwd): $!";
		my @st_pwd = stat($pwd); # PWD invalid, use cwd
		# make sure st_dev/st_ino match for {PWD} to be valid
		$pwd = $cwd if (!@st_pwd || $st_pwd[1] != $st_cwd[1] ||
					$st_pwd[0] != $st_cwd[0]);
	} else {
		$pwd = $cwd;
	}
	1;
}) { # (Socket::MsgHdr|IO::FDPass|Inline::C), $sock, $pwd are all available:
	local $ENV{PWD} = $pwd;
	my $buf = join("\0", scalar(@ARGV), @ARGV);
	while (my ($k, $v) = each %ENV) { $buf .= "\0$k=$v" }
	$buf .= "\0\0";
	select $sock;
	$| = 1; # unbuffer selected $sock
	$send_cmd->($sock, [ 0, 1, 2 ], $buf, 0);
	while (my (@fds) = $recv_cmd->($sock, $buf, 4096 * 33)) {
		if ($buf =~ /\Aexit=([0-9]+)\n\z/) {
			exit($1);
		} elsif ($buf =~ /\Aexec (.+)\n\z/) {
			exec_cmd(\@fds, split(/\0/, $1));
		} else {
			die $buf;
		}
	}
} else { # for systems lacking Socket::MsgHdr, IO::FDPass or Inline::C
	warn $@ if $@;
	require PublicInbox::LEI;
	PublicInbox::LEI::oneshot(__PACKAGE__);
}
