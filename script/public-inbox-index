#!perl -w
# Copyright (C) 2015-2020 all contributors <meta@public-inbox.org>
# License: AGPL-3.0+ <https://www.gnu.org/licenses/agpl-3.0.txt>
# Basic tool to create a Xapian search index for a public-inbox.
# Usage with libeatmydata <https://www.flamingspork.com/projects/libeatmydata/>
# highly recommended: eatmydata public-inbox-index INBOX_DIR

use strict;
use v5.10.1;
use Getopt::Long qw(:config gnu_getopt no_ignore_case auto_abbrev);
my $usage = 'public-inbox-index [options] INBOX_DIR';
my $help = <<EOF; # the following should fit w/o scrolling in 80x24 term:
usage: $usage

  Create and update search indices

options:

  --no-fsync          speed up indexing, risk corruption on power outage
  -L LEVEL            `basic', `medium', or `full' (default: full)
  --all               index all configured inboxes
  --compact | -c      run public-inbox-compact(1) after indexing
  --sequential-shard  index Xapian shards sequentially for slow storage
  --jobs=NUM          set or disable parallelization (NUM=0)
  --batch-size=BYTES  flush changes to OS after a given number of bytes
  --max-size=BYTES    do not index messages larger than the given size
  --reindex           index previously indexed data (if upgrading)
  --rethread          regenerate thread IDs (if upgrading, use sparingly)
  --prune             prune git storage on discontiguous history
  --verbose | -v      increase verbosity (may be repeated)
  --help | -?         show this help

BYTES may use `k', `m', and `g' suffixes (e.g. `10m' for 10 megabytes)
See public-inbox-index(1) man page for full documentation.
EOF
my $opt = { quiet => -1, compact => 0, max_size => undef, fsync => 1 };
GetOptions($opt, qw(verbose|v+ reindex rethread compact|c+ jobs|j=i prune
		fsync|sync! xapian_only|xapian-only
		indexlevel|index-level|L=s max_size|max-size=s
		batch_size|batch-size=s
		sequential_shard|seq-shard|sequential-shard
		all help|?))
	or die "bad command-line args\n$usage";
if ($opt->{help}) { print $help; exit 0 };
die "--jobs must be >= 0\n" if defined $opt->{jobs} && $opt->{jobs} < 0;
if ($opt->{xapian_only} && !$opt->{reindex}) {
	die "--xapian-only requires --reindex\n";
}

# require lazily to speed up --help
require PublicInbox::Admin;
PublicInbox::Admin::require_or_die('-index');

my $cfg = PublicInbox::Config->new; # Config is loaded by Admin
my @ibxs = PublicInbox::Admin::resolve_inboxes(\@ARGV, $opt, $cfg);
PublicInbox::Admin::require_or_die('-index');
unless (@ibxs) { print STDERR "Usage: $usage\n"; exit 1 }

my $mods = {};
foreach my $ibx (@ibxs) {
	# XXX: users can shoot themselves in the foot, with opt->{indexlevel}
	$ibx->{indexlevel} //= $opt->{indexlevel} // ($opt->{xapian_only} ?
			'full' : PublicInbox::Admin::detect_indexlevel($ibx));
	PublicInbox::Admin::scan_ibx_modules($mods, $ibx);
}

PublicInbox::Admin::require_or_die(keys %$mods);
my $env = PublicInbox::Admin::index_prepare($opt, $cfg);
local %ENV = (%ENV, %$env) if $env;
require PublicInbox::InboxWritable;
PublicInbox::Admin::progress_prepare($opt);
for my $ibx (@ibxs) {
	$ibx = PublicInbox::InboxWritable->new($ibx);
	if ($opt->{compact} >= 2) {
		PublicInbox::Xapcmd::run($ibx, 'compact', $opt->{compact_opt});
	}
	$ibx->{-no_fsync} = 1 if !$opt->{fsync};

	my $ibx_opt = $opt;
	if (defined(my $s = $ibx->{lc('indexSequentialShard')})) {
		defined(my $v = $cfg->git_bool($s)) or die <<EOL;
publicInbox.$ibx->{name}.indexSequentialShard not boolean
EOL
		$ibx_opt = { %$opt, sequential_shard => $v };
	}
	PublicInbox::Admin::index_inbox($ibx, undef, $ibx_opt);
	if (my $copt = $opt->{compact_opt}) {
		local $copt->{jobs} = 0 if $ibx_opt->{sequential_shard};
		PublicInbox::Xapcmd::run($ibx, 'compact', $copt);
	}
}
