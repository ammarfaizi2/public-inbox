#!/usr/bin/perl -w
# Copyright (C) 2014-2019 all contributors <meta@public-inbox.org>
# License: AGPL-3.0+ <https://www.gnu.org/licenses/agpl-3.0.txt>
#
# Initializes a public-inbox, basically a wrapper for git-init(1)
use strict;
use warnings;
sub usage {
	print STDERR <<EOF;
Usage: public-inbox-init NAME INBOX_DIR HTTP_URL ADDRESS [ADDRESS..]
EOF
	exit 1;
}
use Getopt::Long qw/:config gnu_getopt no_ignore_case auto_abbrev/;
use PublicInbox::Admin;
PublicInbox::Admin::require_or_die('-base');
require PublicInbox::Config;
require PublicInbox::InboxWritable;
use File::Temp qw/tempfile/;
use PublicInbox::Lock;
use File::Basename qw/dirname/;
use File::Path qw/mkpath/;
use Fcntl qw(:DEFAULT);
use Cwd qw/abs_path/;

sub x { system(@_) and die join(' ', @_). " failed: $?\n" }
my $version = undef;
my $indexlevel = undef;
my $skip_epoch;
my %opts = (
	'V|version=i' => \$version,
	'L|indexlevel=s' => \$indexlevel,
	'S|skip|skip-epoch=i' => \$skip_epoch,
);
GetOptions(%opts) or usage();
PublicInbox::Admin::indexlevel_ok_or_die($indexlevel) if defined $indexlevel;
my $name = shift @ARGV or usage();
my $inboxdir = shift @ARGV or usage();
my $http_url = shift @ARGV or usage();
my (@address) = @ARGV;
@address or usage();
my %seen;

my $pi_config = PublicInbox::Config->default_file;
my $dir = dirname($pi_config);
mkpath($dir); # will croak on fatal errors

# first, we grab a flock to prevent simultaneous public-inbox-init
# processes from trampling over each other, or exiting with 255 on
# O_EXCL failure below.  This gets unlocked automatically on exit:
my $lock_obj = { lock_path => "$pi_config.flock" };
PublicInbox::Lock::lock_acquire($lock_obj);

# git-config will operate on this (and rename on success):
my ($fh, $pi_config_tmp) = tempfile('pi-init-XXXXXXXX', DIR => $dir);

# Now, we grab another lock to use git-config(1) locking, so it won't
# wait on the lock, unlike some of our internal flock()-based locks.
# This is to prevent direct git-config(1) usage from clobbering our
# changes.
my $lockfile = "$pi_config.lock";
my $lockfh;
sysopen($lockfh, $lockfile, O_RDWR|O_CREAT|O_EXCL) or do {
	warn "could not open config file: $lockfile: $!\n";
	exit(255);
};
my $auto_unlink = UnlinkMe->new($lockfile);
my $perm;
if (-e $pi_config) {
	open(my $oh, '<', $pi_config) or die "unable to read $pi_config: $!\n";
	my @st = stat($oh);
	$perm = $st[2];
	defined $perm or die "(f)stat failed on $pi_config: $!\n";
	chmod($perm & 07777, $fh) or
		die "(f)chmod failed on future $pi_config: $!\n";
	my $old;
	{
		local $/;
		$old = <$oh>;
	}
	print $fh $old or die "failed to write: $!\n";
	close $oh or die "failed to close $pi_config: $!\n";

	# yes, this conflict checking is racy if multiple instances of this
	# script are run by the same $PI_DIR
	my $cfg = PublicInbox::Config->new;
	my $conflict;
	foreach my $addr (@address) {
		my $found = $cfg->lookup($addr);
		if ($found) {
			if ($found->{name} ne $name) {
				print STDERR
					"`$addr' already defined for ",
					"`$found->{name}',\n",
					"does not match intend `$name'\n";
				$conflict = 1;
			} else {
				$seen{lc($addr)} = 1;
			}
		}
	}

	exit(1) if $conflict;

	my $ibx = $cfg->lookup_name($name);
	if ($ibx) {
		if (!defined($indexlevel) && $ibx->{indexlevel}) {
			$indexlevel = $ibx->{indexlevel};
		}
	}
}
close $fh or die "failed to close $pi_config_tmp: $!\n";

my $pfx = "publicinbox.$name";
my @x = (qw/git config/, "--file=$pi_config_tmp");

$inboxdir = abs_path($inboxdir);
if (-f "$inboxdir/inbox.lock") {
	if (!defined $version) {
		$version = 2;
	} elsif ($version != 2) {
		die "$inboxdir is a -V2 repo, -V$version specified\n"
	}
} elsif (-d "$inboxdir/objects") {
	if (!defined $version) {
		$version = 1;
	} elsif ($version != 1) {
		die "$inboxdir is a -V1 repo, -V$version specified\n"
	}
}

$version = 1 unless defined $version;

if ($version == 1 && defined $skip_epoch) {
	die "--skip-epoch is only supported for -V2 repos\n";
}

my $ibx = PublicInbox::Inbox->new({
	inboxdir => $inboxdir,
	name => $name,
	version => $version,
	-primary_address => $address[0],
	indexlevel => $indexlevel,
});

my $creat_opt = {};
PublicInbox::InboxWritable->new($ibx, $creat_opt)->init_inbox(0, $skip_epoch);

# needed for git prior to v2.1.0
umask(0077) if defined $perm;

foreach my $addr (@address) {
	next if $seen{lc($addr)};
	x(@x, "--add", "$pfx.address", $addr);
}
x(@x, "$pfx.url", $http_url);
x(@x, "$pfx.inboxdir", $inboxdir);

if (defined($indexlevel)) {
	x(@x, "$pfx.indexlevel", $indexlevel);
}

# needed for git prior to v2.1.0
if (defined $perm) {
	chmod($perm & 07777, $pi_config_tmp) or
			die "(f)chmod failed on future $pi_config: $!\n";
}

rename $pi_config_tmp, $pi_config or
	die "failed to rename `$pi_config_tmp' to `$pi_config': $!\n";
$auto_unlink->DESTROY;

package UnlinkMe;
use strict;

sub new {
	my ($klass, $file) = @_;
	bless { file => $file }, $klass;
}

sub DESTROY {
	my $f = delete($_[0]->{file});
	unlink($f) if defined($f);
}
1;
