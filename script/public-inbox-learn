#!/usr/bin/perl -w
# Copyright (C) 2014-2019 all contributors <meta@public-inbox.org>
# License: AGPL-3.0+ <https://www.gnu.org/licenses/agpl-3.0.txt>
#
# Used for training spam (via SpamAssassin) and removing messages from a
# public-inbox
my $usage = "$0 (spam|ham) < /path/to/message";
use strict;
use warnings;
use PublicInbox::Config;
use PublicInbox::InboxWritable;
use PublicInbox::MIME;
use PublicInbox::Address;
use PublicInbox::Spamcheck::Spamc;
my $train = shift or die "usage: $usage\n";
if ($train !~ /\A(?:ham|spam|rm)\z/) {
	die "`$train' not recognized.\nusage: $usage\n";
}

my $spamc = PublicInbox::Spamcheck::Spamc->new;
my $pi_config = PublicInbox::Config->new;
my $err;
my $mime = PublicInbox::MIME->new(eval {
	local $/;
	my $data = scalar <STDIN>;
	$data =~ s/\A[\r\n]*From [^\r\n]*\r?\n//s;

	if ($train ne 'rm') {
		eval {
			if ($train eq 'ham') {
				$spamc->hamlearn(\$data);
			} elsif ($train eq 'spam') {
				$spamc->spamlearn(\$data);
			}
			die "spamc failed with: $?\n" if $?;
		};
		$err = $@;
	}
	$data
});

# spam is removed from all known inboxes
if ($train eq 'spam') {
	$pi_config->each_inbox(sub {
		my ($ibx) = @_;
		$ibx = PublicInbox::InboxWritable->new($ibx);
		my $im = $ibx->importer(0);
		$im->remove($mime, 'spam');
		$im->done;
	});
} else {
	require PublicInbox::MDA if $train eq "ham";

	# get all recipients
	my %dests; # address => <PublicInbox::Inbox|0(false)>
	for ($mime->header('Cc'), $mime->header('To')) {
		foreach my $addr (PublicInbox::Address::emails($_)) {
			$addr = lc($addr);
			$dests{$addr} //= $pi_config->lookup($addr) // 0;
		}
	}

	# n.b. message may be cross-posted to multiple public-inboxes
	while (my ($addr, $dst) = each %dests) {
		next unless ref($dst);
		# We do not touch GIT_COMMITTER_* env here so we can track
		# who trained the message.
		$dst->{name} = $ENV{GIT_COMMITTER_NAME} || $dst->{name};
		$dst->{-primary_address} = $ENV{GIT_COMMITTER_EMAIL} || $addr;
		$dst = PublicInbox::InboxWritable->new($dst);
		my $im = $dst->importer(0);

		if ($train eq "rm") {
			# This needs to be idempotent, as my inotify trainer
			# may train for each cross-posted message, and this
			# script already learns for every list in
			# ~/.public-inbox/config
			$im->remove($mime, $train);
		} elsif ($train eq "ham") {
			# no checking for spam here, we assume the message has
			# been reviewed by a human at this point:
			PublicInbox::MDA->set_list_headers($mime, $dst);

			# Ham messages are trained when they're marked into
			# a SEEN state, so this is idempotent:
			$im->add($mime);
		}
		$im->done;
	}
}

if ($err) {
	warn $err;
	exit 1;
}
