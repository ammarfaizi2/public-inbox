#!/usr/bin/perl -w
# Copyright (C) 2014-2019 all contributors <meta@public-inbox.org>
# License: AGPL-3.0+ <https://www.gnu.org/licenses/agpl-3.0.txt>
#
# Used for training spam (via SpamAssassin) and removing messages from a
# public-inbox
my $usage = "$0 <spam|ham|rm> </path/to/message";
use strict;
use warnings;
use PublicInbox::Config;
use PublicInbox::InboxWritable;
use PublicInbox::MIME;
use PublicInbox::Address;
use PublicInbox::Spamcheck::Spamc;
my $train = shift or die "usage: $usage\n";
if ($train !~ /\A(?:ham|spam|rm)\z/) {
	die "`$train' not recognized.\nusage: $usage\n";
}

my $spamc = PublicInbox::Spamcheck::Spamc->new;
my $pi_config = PublicInbox::Config->new;
my $err;
my $mime = PublicInbox::MIME->new(eval {
	local $/;
	my $data = scalar <STDIN>;
	$data =~ s/\A[\r\n]*From [^\r\n]*\r?\n//s;

	if ($train ne 'rm') {
		eval {
			if ($train eq 'ham') {
				$spamc->hamlearn(\$data);
			} elsif ($train eq 'spam') {
				$spamc->spamlearn(\$data);
			}
			die "spamc failed with: $?\n" if $?;
		};
		$err = $@;
	}
	$data
});

sub remove_or_add ($$$) {
	my ($ibx, $train, $addr) = @_;

	# We do not touch GIT_COMMITTER_* env here so we can track
	# who trained the message.
	$ibx->{name} = $ENV{GIT_COMMITTER_NAME} // $ibx->{name};
	$ibx->{-primary_address} = $ENV{GIT_COMMITTER_EMAIL} // $addr;
	$ibx = PublicInbox::InboxWritable->new($ibx);
	my $im = $ibx->importer(0);

	if ($train eq "rm") {
		# This needs to be idempotent, as my inotify trainer
		# may train for each cross-posted message, and this
		# script already learns for every list in
		# ~/.public-inbox/config
		$im->remove($mime, $train);
	} elsif ($train eq "ham") {
		# no checking for spam here, we assume the message has
		# been reviewed by a human at this point:
		PublicInbox::MDA->set_list_headers($mime, $ibx);

		# Ham messages are trained when they're marked into
		# a SEEN state, so this is idempotent:
		$im->add($mime);
	}
	$im->done;
}

# spam is removed from all known inboxes since it is often Bcc:-ed
if ($train eq 'spam') {
	$pi_config->each_inbox(sub {
		my ($ibx) = @_;
		$ibx = PublicInbox::InboxWritable->new($ibx);
		my $im = $ibx->importer(0);
		$im->remove($mime, 'spam');
		$im->done;
	});
} else {
	require PublicInbox::MDA;

	# get all recipients
	my %dests; # address => <PublicInbox::Inbox|0(false)>
	for ($mime->header('Cc'), $mime->header('To')) {
		foreach my $addr (PublicInbox::Address::emails($_)) {
			$addr = lc($addr);
			$dests{$addr} //= $pi_config->lookup($addr) // 0;
		}
	}

	# n.b. message may be cross-posted to multiple public-inboxes
	my %seen;
	while (my ($addr, $ibx) = each %dests) {
		next unless ref($ibx); # $ibx may be 0
		next if $seen{"$ibx"}++;
		remove_or_add($ibx, $train, $addr);
	}
	my $ibx = PublicInbox::MDA->inbox_for_list_id($pi_config, $mime);
	if ($ibx && !$seen{"$ibx"}) {
		remove_or_add($ibx, $train, $ibx->{-primary_address});
	}
}

if ($err) {
	warn $err;
	exit 1;
}
