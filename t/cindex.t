#!perl -w
# Copyright (C) all contributors <meta@public-inbox.org>
# License: AGPL-3.0+ <https://www.gnu.org/licenses/agpl-3.0.txt>
use v5.12;
use PublicInbox::TestCommon;
use Cwd qw(getcwd abs_path);
use List::Util qw(sum);
require_mods(qw(json Search::Xapian));
use_ok 'PublicInbox::CodeSearchIdx';
require PublicInbox::Import;
my ($tmp, $for_destroy) = tmpdir();
my $pwd = getcwd();
my @unused_keys = qw(last_commit has_threadid skip_docdata);

# I reworked CodeSearchIdx->shard_worker to handle empty trees
# in the initial commit generated by cvs2svn for xapian.git
create_coderepo 'empty-tree-root-0600', tmpdir => "$tmp/wt0", sub {
	xsys_e([qw(/bin/sh -c), <<'EOM']);
git init -q &&
git config core.sharedRepository 0600
tree=$(git mktree </dev/null) &&
head=$(git symbolic-ref HEAD) &&
cmt=$(echo 'empty root' | git commit-tree $tree) &&
git update-ref $head $cmt &&
echo hi >f &&
git add f &&
git commit -q -m hi &&
git gc -q
EOM
}; # /create_coderepo

ok(run_script([qw(-cindex --dangerous -q), "$tmp/wt0"]), 'cindex internal');
{
	my $exists = -e "$tmp/wt0/.git/public-inbox-cindex/cidx.lock";
	my @st = stat(_);
	ok($exists, 'internal dir created');
	is($st[2] & 0600, 0600, 'mode respects core.sharedRepository');
	@st = stat("$tmp/wt0/.git/public-inbox-cindex");
	is($st[2] & 0700, 0700, 'dir mode respects core.sharedRepository');
}

# it's possible for git to emit NUL characters in diffs
# (see c4201214cbf10636e2c1ab9131573f735b42c8d4 in linux.git)
my $zp = create_coderepo 'NUL in patch', sub {
	require PublicInbox::Git;
	my $src = PublicInbox::Git::try_cat("$pwd/COPYING");
	xsys_e([qw(git init -q)]);

	# needs to be further than FIRST_FEW_BYTES (8000) in git.git
	$src =~ s/\b(Limitation of Liability\.)\n\n/$1\n\0\n/s or
		xbail "BUG: no `\\n\\n' in $pwd/COPYING";

	open my $fh, '>', 'f' or xbail "open: $!";
	print $fh $src or xbail "print: $!";
	close $fh or xbail "close: $!";
	xsys_e([qw(/bin/sh -c), <<'EOM']);
git add f &&
git commit -q -m 'initial with NUL character'
EOM
	$src =~ s/\n\0\n/\n\n/ or xbail "BUG: no `\\n\\0\\n'";
	open $fh, '>', 'f' or xbail "open: $!";
	print $fh $src or xbail "print: $!";
	close $fh or xbail "close: $!";
	xsys_e([qw(/bin/sh -c), <<'EOM']);
git add f &&
git commit -q -m 'remove NUL character' &&
git gc -q
EOM
}; # /create_coderepo

ok(run_script([qw(-cindex --dangerous -q -d), "$tmp/ext", $zp, "$tmp/wt0"]),
	'cindex external');
ok(-e "$tmp/ext/cidx.lock", 'external dir created');
ok(!-d "$zp/.git/public-inbox-cindex", 'no cindex in original coderepo');

ok(run_script([qw(-cindex -L medium --dangerous -q -d),
	"$tmp/med", $zp, "$tmp/wt0"]), 'cindex external medium');


SKIP: {
	have_xapian_compact;
	ok(run_script([qw(-compact -q), "$tmp/ext"]), 'compact on full');
	ok(run_script([qw(-compact -q), "$tmp/med"]), 'compact on medium');
}

my $no_metadata_set = sub {
	my ($i, $extra, $xdb) = @_;
	for my $xdb (@$xdb) {
		for my $k (@unused_keys, @$extra) {
			is($xdb->get_metadata($k) // '', '',
				"metadata $k unset in shard #$i");
		}
		++$i;
	}
};

{
	my $mid_size = sum(map { -s $_ } glob("$tmp/med/cidx*/*/*"));
	my $full_size = sum(map { -s $_ } glob("$tmp/ext/cidx*/*/*"));
	ok($full_size > $mid_size, 'full size > mid size') or
		diag "full=$full_size mid=$mid_size";
	for my $l (qw(med ext)) {
		ok(run_script([qw(-cindex -q --reindex -u -d), "$tmp/$l"]),
			"reindex $l");
	}
	$mid_size = sum(map { -s $_ } glob("$tmp/med/cidx*/*/*"));
	$full_size = sum(map { -s $_ } glob("$tmp/ext/cidx*/*/*"));
	ok($full_size > $mid_size, 'full size > mid size after reindex') or
		diag "full=$full_size mid=$mid_size";
	my $csrch = PublicInbox::CodeSearch->new("$tmp/med");
	my ($xdb0, @xdb) = $csrch->xdb_shards_flat;
	$no_metadata_set->(0, [], [ $xdb0 ]);
	is($xdb0->get_metadata('indexlevel'), 'medium',
		'indexlevel set in shard #0');
	$no_metadata_set->(1, ['indexlevel'], \@xdb);

	ok(run_script([qw(-cindex -q -L full --reindex -u -d), "$tmp/med"]),
		'reindex medium as full');
	@xdb = $csrch->xdb_shards_flat;
	$no_metadata_set->(0, ['indexlevel'], \@xdb);
}

use_ok 'PublicInbox::CodeSearch';

if ('multi-repo search') {
	my $csrch = PublicInbox::CodeSearch->new("$tmp/ext");
	my $mset = $csrch->mset('NUL');
	is(scalar($mset->items), 2, 'got results');
	my $exp = [ 'initial with NUL character', 'remove NUL character' ];
	my @have = sort(map { $_->get_document->get_data } $mset->items);
	is_xdeeply(\@have, $exp, 'got expected subjects');

	$mset = $csrch->mset('NUL', { git_dir => "$tmp/wt0/.git" });
	is(scalar($mset->items), 0, 'no results with other GIT_DIR');

	$mset = $csrch->mset('NUL', { git_dir => abs_path("$zp/.git") });
	@have = sort(map { $_->get_document->get_data } $mset->items);
	is_xdeeply(\@have, $exp, 'got expected subjects w/ GIT_DIR filter');
	my @xdb = $csrch->xdb_shards_flat;
	$no_metadata_set->(0, ['indexlevel'], \@xdb);
}

if ('--update') {
	my $csrch = PublicInbox::CodeSearch->new("$tmp/ext");
	my $mset = $csrch->mset('dfn:for-update');
	is(scalar($mset->items), 0, 'no result before update');

	my $e = \%PublicInbox::TestCommon::COMMIT_ENV;
	xsys_e([qw(/bin/sh -c), <<'EOM'], $e, { -C => "$tmp/wt0" });
>for-update && git add for-update && git commit -q -m updated
EOM
	ok(run_script([qw(-cindex -qu -d), "$tmp/ext"]), '-cindex -u');
	$mset = $csrch->reopen->mset('dfn:for-update');
	is(scalar($mset->items), 1, 'got updated result');

	ok(run_script([qw(-cindex -qu --reindex -d), "$tmp/ext"]), 'reindex');
	$mset = $csrch->reopen->mset('dfn:for-update');
	is(scalar($mset->items), 1, 'same result after reindex');
}

if ('--prune') {
	my $csrch = PublicInbox::CodeSearch->new("$tmp/ext");
	is(scalar($csrch->mset('s:hi')->items), 1, 'got hit');

	rename("$tmp/wt0/.git", "$tmp/wt0/.giit") or xbail "rename $!";
	ok(run_script([qw(-cindex -q --prune -d), "$tmp/ext"]), 'prune');
	$csrch->reopen;
	is(scalar($csrch->mset('s:hi')->items), 0, 'hit pruned');

	rename("$tmp/wt0/.giit", "$tmp/wt0/.git") or xbail "rename $!";
	ok(run_script([qw(-cindex -qu -d), "$tmp/ext"]), 'update');
	$csrch->reopen;
	is(scalar($csrch->mset('s:hi')->items), 0,
		'hit stays pruned since GIT_DIR was previously pruned');
	isnt(scalar($csrch->mset('s:NUL')->items), 0,
		'prune did not clobber entire index');
}

File::Path::remove_tree("$tmp/ext");
ok(mkdir("$tmp/ext", 0707), 'create $tmp/ext with odd permissions');
ok(run_script([qw(-cindex --dangerous -q -d), "$tmp/ext", $zp]),
	'external on existing dir');
{
	my @st = stat("$tmp/ext/cidx.lock");
	is($st[2] & 0777, 0604, 'created lock respects odd permissions');
}

done_testing;
