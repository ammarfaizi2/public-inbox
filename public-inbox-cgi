#!/usr/bin/perl -w
# Copyright (C) 2014, Eric Wong <normalperson@yhbt.net> and all contributors
# License: AGPLv3 or later (https://www.gnu.org/licenses/agpl-3.0.txt)
#
# We focus on the lowest common denominators here:
# - targeted at text-only console browsers (lynx, w3m, etc..)
# - Only basic HTML, CSS only for line-wrapping <pre> text content for GUIs
# - No JavaScript, graphics or icons allowed.
# - Must not rely on static content
# - UTF-8 is only for user-content, 7-bit US-ASCII for us

use 5.008;
use strict;
use warnings;
use CGI qw(:cgi :escapeHTML -nosticky); # PSGI/FastCGI/mod_perl compat
use Encode qw(decode_utf8);
use PublicInbox::Config;
our $LISTNAME_RE = qr!\A/([\w\.\-]+)!;
our $pi_config;
BEGIN {
	$pi_config = PublicInbox::Config->new;
	# TODO: detect and reload config as needed
	if ($ENV{MOD_PERL}) {
		CGI->compile;
	}
}

binmode STDOUT, ':utf8';

my $ret = main();

my ($status, $headers, $body) = @$ret;
if (@ARGV && $ARGV[0] eq 'static') {
	print $body;
} else { # CGI
	print "Status: $status\r\n";
	while (my ($k, $v) = each %$headers) {
		print "$k: $v\r\n";
	}
	print "\r\n", $body;
}

# TODO: plack support

# private functions below

sub main {
	my $cgi = CGI->new;
	my %ctx;
	if ($cgi->request_method !~ /\AGET|HEAD\z/) {
		return r("405 Method Not Allowed");
	}
	my $path_info = decode_utf8($ENV{PATH_INFO});

	# top-level indices and feeds
	if ($path_info eq "/") {
		r404();
	} elsif ($path_info =~ m!$LISTNAME_RE/?\z!o) {
		invalid_list(\%ctx, $1) || get_list_log(\%ctx, $cgi);
	} elsif ($path_info =~ m!$LISTNAME_RE/all\z!o) {
		invalid_list(\%ctx, $1) || get_list_all(\%ctx, $cgi);
	} elsif ($path_info =~ m!$LISTNAME_RE/index\.atom\.xml\z!o) {
		invalid_list(\%ctx, $1) || get_atom(\%ctx, $cgi, 1);
	} elsif ($path_info =~ m!$LISTNAME_RE/all\.atom\.xml\z!o) {
		invalid_list(\%ctx, $1) || get_atom(\%ctx, $cgi, 0);

	# single-message pages
	} elsif ($path_info =~ m!$LISTNAME_RE/mid/(\S+)\.txt\z!o) {
		get_mid_txt($cgi, $1, $2);
	} elsif ($path_info =~ m!$LISTNAME_RE/mid/(\S+)\.html\z!o) {
		get_mid_html($cgi, $1, $2);
	} elsif ($path_info =~ m!$LISTNAME_RE/mid/(\S+)\z!o) {
		redirect_mid_html($cgi, $1, $2);
	} else {
		r404();
	}
}

sub r404 { r("404 Not Found") }

# simple response for errors
sub r { [ $_[0], { 'Content-Type' => 'text/plain' }, '' ] }

# returns undef if valid, array ref response if invalid
sub invalid_list {
	my ($ctx, $listname) = @_;
	my $git_dir = $pi_config->get($listname, "mainrepo");
	if (defined $git_dir) {
		$ctx->{git_dir} = $git_dir;
		$ctx->{listname} = $listname;
		return undef;
	}
	r404();
}

# returns undef if valid, array ref response if invalid
sub invalid_list_mid {
	my ($ctx, $listname, $mid) = @_;
	my $ret = invalid_list($ctx, $listname, $mid) and return $ret;
	$ctx->{mid} = $mid;
	undef;
}

sub get_atom {
	my ($ctx, $cgi, $top) = @_;
	require PublicInbox::Feed;
	[ '200 OK', { 'Content-Type' => 'application/xml' },
	  PublicInbox::Feed->generate({
			git_dir => $ctx->{git_dir},
			listname => $ctx->{listname},
			pi_config => $pi_config,
			cgi => $cgi,
			top => $top,
		})
	];
}
